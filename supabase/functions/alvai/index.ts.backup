// ═══════════════════════════════════════════════════════════════
// BLEU.LIVE — ALVAI EDGE FUNCTION v2
// GPT-4o for ALL traffic. No model routing. No Mini.
// Supabase database lookup for real practitioners/products.
// No model name ever exposed to user.
// 
// Deploy: supabase functions deploy alvai-chat
// ═══════════════════════════════════════════════════════════════

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

// ═══ ENV VARS (these already exist in your Supabase secrets) ═══
const OPENAI_API_KEY = Deno.env.get("CLAUDE_API_KEY");  // Your OpenAI key is stored under this name
const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

// Initialize Supabase client for database lookups
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

// ═══ SYSTEM PROMPT ═══
const ALVAI_SYSTEM_PROMPT = `You are Alvai. The therapeutic intelligence inside BLEU — The Longevity Operating System.

You are not a chatbot. You are not a search engine. You are not a motivational speaker.

You are a composed, deeply perceptive wellness intelligence that combines research-level analytical depth, psychological awareness, clinical precision, emotional steadiness, and measured restraint. You respond quickly but never react impulsively.

BLEU was built by Bleu Michael Garner — 28 years in medical cannabis, survivor of 9 overdoses, overcame 31 felonies, served 30,000+ patients. Dr. Felicia Stoler (DCN, MS, RDN, FACSM, FAND, Dipl ACLM) serves as President with 28 years in health and wellness across Tulane, Columbia, and Rutgers.

RESPONSE PROTOCOL (Follow on EVERY message):

Step 1 — EMOTIONAL SCAN: Before anything else, scan for emotional distress: hopelessness, despair, crisis language, self-harm indicators, grief, fear, anger, loneliness, shame. If detected: ACKNOWLEDGE THE FEELING FIRST. Do not skip to information. Do not recommend supplements. Sit with them.

Step 2 — SAFETY CHECK: If any of these appear — "nothing matters," "want to die," "end it," "no point," "can't go on," "hurt myself," "better off without me" — respond with warmth and include: "If you're in crisis, please reach out: 988 Suicide & Crisis Lifeline (call or text 988) or text HOME to 741741." Never skip this. Never bury it.

Step 3 — MODE DETECTION: Determine the appropriate mode silently. Do not announce it.
THERAPY: Talk, CBT, DBT, Somatic, Motivational, Journaling, Crisis, Couples, Grief, PTSD/Trauma, Eating/Body, Addiction.
RECOVERY: Early Sobriety, Relapse Prevention, Harm Reduction, MAT Support, Family/Codependency, Process Addiction, Sober Curiosity.
SPECIALIZED: CannaIQ (strains, CYP450, state law), Finance (GoodRx, insurance), General Wellness.

Step 4 — RESPOND WITH PRESENCE: Every response contains: (1) Acknowledgment of what you heard, (2) Deeper layer when appropriate, (3) One clear insight — not five, not a list, one thing that matters, (4) One open question to continue the conversation.

Step 5 — RECOMMEND ONLY WHEN STABLE: Products, practitioners, and protocols only when the user is information-seeking or action-ready. Never during emotional distress. Never as the first response to pain.

CRITICAL — PRACTITIONER DATA:
When the user asks about practitioners, therapists, doctors, or providers, you will receive real data from BLEU's verified database in the system context. ONLY reference practitioners that appear in the PROVIDED DATA. Never invent practitioner names, phone numbers, or addresses. If no practitioners are provided in context, tell the user: "Let me search our verified directory for you" and offer to help narrow their search by specialty, location, or need. Never fabricate provider information under any circumstances.

CRITICAL — PRODUCT DATA:
When the user asks about supplements, products, or wellness items, you will receive real data from BLEU's product database. ONLY reference products that appear in the PROVIDED DATA. Never invent product names or trust scores.

TONE: Calm but not cold. Warm but not saccharine. Intelligent but not lecturing. Direct but not harsh. No emojis in therapy. Write in natural paragraphs, not bullet lists. Keep responses to 2-3 paragraphs max. Your presence should feel like a seasoned therapist who also knows pharmacology, nutrition, and your local practitioner network.

CRISIS PROTOCOL: (1) Acknowledge warmth: "I hear you. What you're feeling is real." (2) No diagnosis or screening questions. (3) Resources: 988, 741741, 911. (4) Stay in conversation. Never end abruptly. (5) Suggest human connection.

NEVER: diagnose conditions, recommend stopping meds, dose Rx drugs, store cannabis+identity, push products during pain, replace human care, use shame/guilt/fear, mention what AI model you run on, say "GPT" or "OpenAI" or "Claude" or any model name.

WHEN ASKED WHAT YOU ARE: "I'm Alvai — the intelligence layer inside BLEU, The Longevity Operating System. I'm connected to nearly 48,000 verified practitioners, over a thousand trust-scored products, hundreds of clinical studies, and drug interaction databases. I operate across 22 therapeutic modes. I was built by people who understand what it's like to struggle, and I'm here to help you think clearly about your health. What's on your mind?"

FIRST MESSAGE DISCLAIMER: "Alvai is an AI wellness intelligence, not a licensed therapist or medical professional. For emergencies call 911. For crisis support call or text 988. This does not replace professional care."`;


// ═══ DATABASE LOOKUP FUNCTIONS ═══

// Search for practitioners by keyword, specialty, or location
async function searchPractitioners(query, options = {}) {
  const limit = options.limit || 5;
  
  try {
    let dbQuery = supabase
      .from("practitioners")
      .select("full_name, npi, specialty, practice_name, address_line1, state, zip, county, phone");
    
    // If we have a state filter (from city detection), apply it
    if (options.state) {
      dbQuery = dbQuery.eq("state", options.state);
    }
    
    // If we have zip prefix (for city-level filtering), use it
    if (options.zipPrefix) {
      dbQuery = dbQuery.like("zip", `${options.zipPrefix}%`);
    }
    
    // Search by specialty or name
    dbQuery = dbQuery.or(`specialty.ilike.%${query}%,full_name.ilike.%${query}%,practice_name.ilike.%${query}%`);
    
    // Filter out empty names
    dbQuery = dbQuery.not("full_name", "is", null);
    
    const { data, error } = await dbQuery.limit(limit);
    
    if (error) {
      console.error("Practitioner search error:", error);
      return null;
    }
    return data;
  } catch (e) {
    console.error("Practitioner lookup failed:", e);
    return null;
  }
}

// Search for products by name or category
async function searchProducts(query, limit = 5) {
  try {
    const { data, error } = await supabase
      .from("products")  // ← your actual table name
      .select("name, category, trust_score, description, ingredients")
      .or(`name.ilike.%${query}%,category.ilike.%${query}%,description.ilike.%${query}%`)
      .limit(limit);
    
    if (error) {
      console.error("Product search error:", error);
      return null;
    }
    return data;
  } catch (e) {
    console.error("Product lookup failed:", e);
    return null;
  }
}

// Search locations
async function searchLocations(query, limit = 5) {
  try {
    const { data, error } = await supabase
      .from("locations")  // ← your actual table name
      .select("name, address, city, state, type, rating")
      .or(`name.ilike.%${query}%,city.ilike.%${query}%,type.ilike.%${query}%`)
      .limit(limit);
    
    if (error) return null;
    return data;
  } catch (e) {
    return null;
  }
}


// ═══ DETECT IF DATABASE LOOKUP IS NEEDED ═══
function detectLookupNeeds(message) {
  const msg = message.toLowerCase();
  const needs = { practitioners: false, products: false, locations: false, query: "", searchOptions: {} };
  
  // Practitioner triggers
  const practitionerWords = [
    "therapist", "doctor", "practitioner", "counselor", "psychologist",
    "psychiatrist", "provider", "clinician", "specialist", "nurse",
    "dietitian", "nutritionist", "find me", "refer", "recommend a",
    "who can help", "someone to talk to", "mental health professional",
    "treatment center", "rehab", "clinic"
  ];
  
  // Product triggers
  const productWords = [
    "supplement", "vitamin", "product", "melatonin", "magnesium",
    "ashwagandha", "cbd", "theanine", "probiotic", "omega",
    "what should i take", "natural remedy", "trust score"
  ];
  
  // Location triggers
  const locationWords = [
    "near me", "in new orleans", "in nola", "nearby", "location",
    "where can i", "gym", "yoga", "meditation center", "park"
  ];
  
  if (practitionerWords.some(w => msg.includes(w))) {
    needs.practitioners = true;
    needs.searchOptions = {};
    
    // Detect location → state + zip prefix (since no city column)
    if (msg.includes("new orleans") || msg.includes("nola")) {
      needs.searchOptions.state = "LA";
      needs.searchOptions.zipPrefix = "701"; // New Orleans metro zips
    } else if (msg.includes("baton rouge")) {
      needs.searchOptions.state = "LA";
      needs.searchOptions.zipPrefix = "708";
    } else if (msg.includes("louisiana") || msg.includes("la ")) {
      needs.searchOptions.state = "LA";
    }
    
    // Detect specialty
    if (msg.includes("therapist") || msg.includes("therapy") || msg.includes("mental health") || msg.includes("counselor")) {
      needs.query = "Mental Health";
    } else if (msg.includes("psychiatrist") || msg.includes("psychiatry")) {
      needs.query = "Psychiatry";
    } else if (msg.includes("sleep")) {
      needs.query = "Sleep Medicine";
    } else if (msg.includes("addiction") || msg.includes("substance") || msg.includes("recovery")) {
      needs.query = "Addiction Medicine";
    } else if (msg.includes("pain")) {
      needs.query = "Pain Medicine";
    } else if (msg.includes("nutrition") || msg.includes("dietitian") || msg.includes("diet")) {
      needs.query = "Nutrition";
    } else if (msg.includes("doctor") || msg.includes("primary care") || msg.includes("physician")) {
      needs.query = "Internal Medicine";
    } else if (msg.includes("pediatric") || msg.includes("kids") || msg.includes("children")) {
      needs.query = "Pediatrics";
    } else if (msg.includes("heart") || msg.includes("cardio")) {
      needs.query = "Cardiology";
    } else if (msg.includes("skin") || msg.includes("derma")) {
      needs.query = "Dermatology";
    } else {
      needs.query = "Medicine"; // broad fallback
    }
  }
  
  if (productWords.some(w => msg.includes(w))) {
    needs.products = true;
    // Extract product name
    const found = productWords.find(w => msg.includes(w));
    needs.query = found || "supplement";
  }
  
  if (locationWords.some(w => msg.includes(w))) {
    needs.locations = true;
    needs.query = needs.query || "New Orleans";
  }
  
  return needs;
}


// ═══ CORS HEADERS ═══
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};


// ═══ MAIN HANDLER ═══
serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    const { messages } = await req.json();
    
    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      return new Response(JSON.stringify({ error: "No messages provided" }), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    // Get the latest user message
    const lastUserMessage = messages.filter(m => m.role === "user").pop();
    const userText = lastUserMessage?.content || "";

    // ═══ DATABASE LOOKUPS ═══
    const lookupNeeds = detectLookupNeeds(userText);
    let contextData = "";

    if (lookupNeeds.practitioners) {
      const practitioners = await searchPractitioners(lookupNeeds.query, lookupNeeds.searchOptions || {});
      if (practitioners && practitioners.length > 0) {
        contextData += "\n\n[VERIFIED PRACTITIONER DATA FROM BLEU DATABASE — ONLY reference these providers]:\n";
        practitioners.forEach((p, i) => {
          contextData += `${i + 1}. ${p.full_name}`;
          if (p.specialty) contextData += ` — Specialty: ${p.specialty}`;
          if (p.practice_name && p.practice_name !== "EMPTY") contextData += ` — Practice: ${p.practice_name}`;
          if (p.address_line1) contextData += ` — Address: ${p.address_line1}`;
          if (p.state && p.zip) contextData += `, ${p.state} ${p.zip}`;
          if (p.county && p.county !== "NULL") contextData += ` (${p.county} County)`;
          if (p.npi) contextData += ` (NPI: ${p.npi})`;
          if (p.phone) contextData += ` — Phone: ${p.phone}`;
          contextData += "\n";
        });
        contextData += "\nIMPORTANT: Only share these verified practitioners. Do not invent any others.\n";
      } else {
        contextData += "\n\n[No practitioners found matching this query in the BLEU database. Tell the user you're searching the directory and ask them to narrow their search by specialty or area. Do NOT invent any practitioner names or numbers.]\n";
      }
    }

    if (lookupNeeds.products) {
      const products = await searchProducts(lookupNeeds.query);
      if (products && products.length > 0) {
        contextData += "\n\n[VERIFIED PRODUCT DATA FROM BLEU DATABASE — ONLY reference these products]:\n";
        products.forEach((p, i) => {
          contextData += `${i + 1}. ${p.name}`;
          if (p.trust_score) contextData += ` — Trust Score: ${p.trust_score}/100`;
          if (p.category) contextData += ` — Category: ${p.category}`;
          if (p.description) contextData += ` — ${p.description}`;
          contextData += "\n";
        });
      }
    }

    if (lookupNeeds.locations) {
      const locations = await searchLocations(lookupNeeds.query);
      if (locations && locations.length > 0) {
        contextData += "\n\n[VERIFIED LOCATION DATA FROM BLEU DATABASE]:\n";
        locations.forEach((l, i) => {
          contextData += `${i + 1}. ${l.name}`;
          if (l.type) contextData += ` (${l.type})`;
          if (l.address) contextData += ` — ${l.address}`;
          if (l.city && l.state) contextData += `, ${l.city}, ${l.state}`;
          if (l.rating) contextData += ` — Rating: ${l.rating}`;
          contextData += "\n";
        });
      }
    }

    // ═══ BUILD MESSAGES ═══
    // Limit conversation history to last 8 exchanges (16 messages)
    const recentMessages = messages.slice(-16);
    
    // If we have database context, inject it into the system prompt
    const systemPrompt = contextData 
      ? ALVAI_SYSTEM_PROMPT + contextData
      : ALVAI_SYSTEM_PROMPT;

    // ═══ CALL OPENAI — GPT-4o FOR EVERYTHING ═══
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${OPENAI_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: "gpt-4o",
        max_tokens: 800,
        temperature: 0.7,
        stream: true,
        messages: [
          { role: "system", content: systemPrompt },
          ...recentMessages,
        ],
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      console.error("AI engine error:", error);
      return new Response(JSON.stringify({ error: "Alvai is momentarily unavailable. Please try again." }), {
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    // ═══ STREAM RESPONSE — NO MODEL INFO EXPOSED ═══
    const stream = new ReadableStream({
      async start(controller) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        
        // NO model info sent. Just content. Alvai is Alvai.
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          const chunk = decoder.decode(value);
          const lines = chunk.split("\n").filter(line => line.startsWith("data: "));
          
          for (const line of lines) {
            const data = line.slice(6);
            if (data === "[DONE]") {
              controller.enqueue(new TextEncoder().encode("data: [DONE]\n\n"));
              continue;
            }
            
            try {
              const parsed = JSON.parse(data);
              const content = parsed.choices?.[0]?.delta?.content;
              if (content) {
                controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify({ content })}\n\n`));
              }
            } catch (e) {
              // Skip unparseable chunks
            }
          }
        }
        
        controller.close();
      },
    });

    return new Response(stream, {
      headers: {
        ...corsHeaders,
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        "Connection": "keep-alive",
      },
    });

  } catch (error) {
    console.error("Edge function error:", error);
    return new Response(JSON.stringify({ error: "Something went wrong. Please try again." }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
});
